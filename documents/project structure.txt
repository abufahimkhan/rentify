Folder Structures in React Projects
#
react
#
webdev
#
javascript
#
typescript
Organizing files and directories within a React project is crucial for maintainability, scalability, and ease of navigation. This article explores the general architecture and folder structures across different scales of React projects, providing clear demonstrations for each level.

1ï¸âƒ£ Level 1: Grouping by "File Types"
This structure is characterized by its simplicity - grouping files by their type:

â””â”€â”€ src/
    â”œâ”€â”€ assets/
    â”œâ”€â”€ api/
    â”œâ”€â”€ configs/
    â”œâ”€â”€ components/
    â”‚   â”œâ”€â”€ SignUpForm.tsx
    â”‚   â”œâ”€â”€ Employees.tsx
    â”‚   â”œâ”€â”€ PaymentForm.tsx
    â”‚   â””â”€â”€ Button.tsx
    â”œâ”€â”€ hooks/
    â”‚   â”œâ”€â”€ usePayment.ts
    â”‚   â”œâ”€â”€ useUpdateEmployee.ts
    â”‚   â”œâ”€â”€ useEmployees.ts
    â”‚   â””â”€â”€ useAuth.tsx
    â”œâ”€â”€ lib/
    â”œâ”€â”€ services/
    â”œâ”€â”€ states/
    â””â”€â”€ utils/
Project Size: Small to Medium
Advantages: Simple & straightforward
Disadvantages:
Will inflate quickly and become hard to maintain
No separation of business concerns
Let's say you have a lot of code revolving around payment. One day the whole business changes or is no longer needed, how easy is it to replace or remove it? With this folder structure, you'll have to go through every folder and the files inside it to make the necessary changes. And if the project keeps growing larger, it'll soon grow into a maintenance hell that will only get worse over time.

2ï¸âƒ£ Level 2: Grouping by "File Types" and Features
As projects grow, the "Level 2" structure introduces grouping by feature within each type:

â””â”€â”€ src/
    â”œâ”€â”€ assets/
    â”œâ”€â”€ api/
    â”œâ”€â”€ configs/
    â”œâ”€â”€ components/
    â”‚   â”œâ”€â”€ auth/
    â”‚   â”‚   â””â”€â”€ SignUpForm.tsx
    â”‚   â”œâ”€â”€ payment/
    â”‚   â”‚   â””â”€â”€ PaymentForm.tsx
    â”‚   â”œâ”€â”€ common/
    â”‚   â”‚   â””â”€â”€ Button.tsx
    â”‚   â””â”€â”€ employees/
    â”‚       â”œâ”€â”€ EmployeeList.tsx
    â”‚       â””â”€â”€ EmployeeSummary.tsx
    â”œâ”€â”€ hooks/
    â”‚   â”œâ”€â”€ auth/
    â”‚   â”‚   â””â”€â”€ useAuth.ts
    â”‚   â”œâ”€â”€ payment/
    â”‚   â”‚   â””â”€â”€ usePayment.ts
    â”‚   â””â”€â”€ employees/
    â”‚       â”œâ”€â”€ useEmployees.ts
    â”‚       â””â”€â”€ useUpdateEmployee.ts
    â”œâ”€â”€ lib/
    â”œâ”€â”€ services/
    â”œâ”€â”€ states/
    â””â”€â”€ utils/
Project Size: Medium to Large
Advantages:
Simple & straightforward
Stuff are grouped by features
Disadvantages:
Logic related to a feature is still spread across multiple folder types
Now let's come back to the problem statement where the payment module needs to be modified or removed. With this structure, it's a lot easier to do that now.

The "Level 2" folder structure is the one that I'd recommend if you don't know what to choose.

3ï¸âƒ£ Level 3: Grouping by Features/Modules
For larger projects, the "Level 3" structure offers a highly modular approach, defining clear boundaries for different aspects of the application within each module:

â””â”€â”€ src/
    â”œâ”€â”€ assets/
    â”œâ”€â”€ modules/
    |   â”œâ”€â”€ core/
    â”‚   â”‚   â”œâ”€â”€ components/
    â”‚   â”‚   â”œâ”€â”€ design-system/
    â”‚   â”‚   â”‚   â””â”€â”€ Button.tsx
    â”‚   â”‚   â”œâ”€â”€ hooks/
    â”‚   â”‚   â”œâ”€â”€ lib/
    â”‚   â”‚   â””â”€â”€ utils/
    â”‚   â”œâ”€â”€ payment/
    â”‚   â”‚   â”œâ”€â”€ components/
    â”‚   â”‚   â”‚   â””â”€â”€ PaymentForm.tsx
    â”‚   â”‚   â”œâ”€â”€ hooks/
    â”‚   â”‚   â”‚   â””â”€â”€ usePayment.ts
    â”‚   â”‚   â”œâ”€â”€ lib/
    â”‚   â”‚   â”œâ”€â”€ services/
    â”‚   â”‚   â”œâ”€â”€ states/
    â”‚   â”‚   â””â”€â”€ utils/
    â”‚   â”œâ”€â”€ auth/
    â”‚   â”‚   â”œâ”€â”€ components/
    â”‚   â”‚   â”‚   â””â”€â”€ SignUpForm.tsx
    â”‚   â”‚   â”œâ”€â”€ hooks/
    â”‚   â”‚   â”‚   â””â”€â”€ useAuth.ts
    â”‚   â”‚   â”œâ”€â”€ lib/
    â”‚   â”‚   â”œâ”€â”€ services/
    â”‚   â”‚   â”œâ”€â”€ states/
    â”‚   â”‚   â””â”€â”€ utils/
    â”‚   â””â”€â”€ employees/
    â”‚       â”œâ”€â”€ components/
    â”‚       â”‚   â”œâ”€â”€ EmployeeList.tsx
    â”‚       â”‚   â””â”€â”€ EmployeeSummary.tsx
    â”‚       â”œâ”€â”€ hooks/
    â”‚       â”‚   â”œâ”€â”€ useEmployees.ts
    â”‚       â”‚   â””â”€â”€ useUpdateEmployee.ts
    â”‚       â”œâ”€â”€ services/
    â”‚       â”œâ”€â”€ states/
    â”‚       â””â”€â”€ utils/
    â””â”€â”€ ...
Project Size: Large and Complex
Advantages:
Stuff are clearly grouped by features/modules
Features/Modules are clear representations of objects in the real world
Disadvantages:
You'll have to be well-aware of the business logic to make the right grouping decisions
With this, if you are to remove or modify the payment logic, you'll know right away where to start.

Give Consistent Meanings to Folder Names
Regardless of the structure level, certain folder names should carry specific meanings. What a folder name means may vary based on your preferences or the project's conventions.

Here's what I usually think about folder names:

UI Components
components: React components - the main UI building blocks.
design-system: Fundamental UI elements and patterns based on the design system.
icons: SVG icons that are meant to be used inline.
React Specific
hooks: Custom React hooks for shared logic.
hocs: React Higher-order Components.
contexts/providers: Contains React Contexts and Providers.
Utilities & External Integrations
utils: Utilities for universal logic that is not related to business logic or any technologies, e.g. string manipulations, mathematic calculations, etc.
lib: Utilities that are related to certain technologies, e.g. DOM manipulations, HTML-related logic, localStorage, IndexedDB, etc.
plugins: Third-party plugins (e.g. i18n, Sentry, etc.)
Business Logic
services: Encapsulates main business & application logic.
helpers: Provides business-specific utilities.
Styles
styles: Contains (global) CSS or CSS-in-JS styles.
TypeScript and Configurations
types: For general TypeScript types, enums and interfaces.
configs: Configs for the application (e.g. environment variables)
constants: Constant, unchanged values (e.g. export const MINUTES_PER_HOUR = 60).
Server Communication
api: For logic that communicates with the server(s).
graphql: GraphQL-specific code.
State Management
states/store: Global state management logic (Zustand, Valtio, Jotai, etc.)
reducers, store, actions, selectors: Redux-specific logic
Routing
routes/router: Defining routes (if you're using React Router or the like).
pages: Defining entry-point components for pages.
Testing
tests: Unit tests and other kinds of tests for your code.
ğŸ Conclusion
Choosing the right folder structure in React projects is essential and should be based on the project's size and complexity. While "Level 1" may suffice for small projects, "Level 2" and "Level 3" offer more organized and modular structures for medium and large projects. Personally, I'd often recommend the "Level 2" folder structure. Also, Understanding common folder names helps maintain a consistent and intuitive architecture across React applications.